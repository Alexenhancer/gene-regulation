sum = apply(counts, 2, sum)
)
stats.per.sample$relative.size <- stats.per.sample$sum / min(stats.per.sample$sum)
kable(stats.per.sample, format = "markdown")
## Set global options for R chunks
knitr::opts_chunk$set(eval=TRUE, cache=TRUE, echo=FALSE)
## Load required librarires
library("edgeR")
library("limma")
library("xtable")
library("knitr")
## setwd("../../") ## Only for testing when the test starts from the scripts directory
## Temporary: set up manually the files and folder.
## We will later improve this by reading the config file from arguments (argv)
source("data/1258-BRM/results/N_VS_S_bowtie2_mm1_sorted_name_params.R")
dir.main <- "."
## Create a specific result directory for this differential analysis
dir.results <- file.path(dir.main, "results", "DEG", paste(sep="", cond1, "_vs_", cond2))
dir.create(path = dir.results, showWarnings = FALSE, recursive = TRUE)
dir.figures <- file.path(dir.results, "figures")
dir.create(path = dir.figures, showWarnings = FALSE, recursive = TRUE)
# Read data from counts files
counts <- readDGE(counts.f)$counts
# Remove summary lines from HTseq files
#noint <- rownames(counts) %in% c("no_feature","ambiguous","too_low_aQual", "not_aligned","alignment_not_unique")
info.rows <- rownames(counts) %in% grep(rownames(counts),
pattern = "__",
value = TRUE)
# Remove all features that have less than 1 reads per millions of reads
cpms <- cpm(counts)                               ## Counts per million reads
## Only keep genes detected in at least n.rep samples, where n.rep is the number of replicates
keep <- (rowSums(cpms > 1) >= n.rep) & !info.rows
counts <- counts[keep,]
# Preparation of tables
colnames(counts) <- sample.names
View(counts)
## The count table must have been loaded prior to the execution of this script
stats.per.sample <- data.frame(
min = apply(counts, 2, min),
Q1 = apply(counts, 2, quantile, 0.25),
median = apply(counts, 2, median),
Q3 = apply(counts, 2, quantile, 0.75),
max = apply(counts, 2, max),
sum = apply(counts, 2, sum)
)
stats.per.sample$relative.size <- stats.per.sample$sum / min(stats.per.sample$sum)
kable(stats.per.sample, format = "markdown")
?ktable
?kable
digits
digits()
getOption("digits")
getOption()
getOption("digits")
## The count table must have been loaded prior to the execution of this script
stats.per.sample <- data.frame(
min = apply(counts, 2, min),
Q1 = apply(counts, 2, quantile, 0.25),
median = apply(counts, 2, median),
Q3 = apply(counts, 2, quantile, 0.75),
max = apply(counts, 2, max),
sum = apply(counts, 2, sum)
)
stats.per.sample$relative.size <- stats.per.sample$sum / min(stats.per.sample$sum)
stats.per.sample$condition <- sample.conditions
kable(stats.per.sample, format = "markdown", digits=2)
## The count table must have been loaded prior to the execution of this script
stats.per.sample <- data.frame(
min = apply(counts, 2, min),
Q1 = apply(counts, 2, quantile, 0.25),
median = apply(counts, 2, median),
Q3 = apply(counts, 2, quantile, 0.75),
max = apply(counts, 2, max),
sum = apply(counts, 2, sum)
)
stats.per.sample$relative.size <- stats.per.sample$sum / min(stats.per.sample$sum)
stats.per.sample$condition <- sample.condition
kable(stats.per.sample, format = "markdown", digits=2)
min(stats.per.sample$sum)
plot(counts)
names(counts)
colnames(counts)
plot(counts[, c("N1", "N1","N2")])
plot(counts[, c("N1", "N2","N3")])
plot(counts[, c("N1", "N2")])
plot(counts[, c("N1", "N3")])
plot(counts[, c("N1", "N2")])
plot(counts[, c("N1", "N4")])
plot(counts[, c("N1", "N2", "N4")])
plot(counts[, c("N2", "N4")])
plot(counts[, c("N1", "N2")])
plot(counts[, c("N2", "N4")])
plot(counts[, c("N1", "N4")])
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c("N1", "N2")])
plot(counts[, c("N2", "N4")])
plot(counts[, c("N1", "N4")])
par(mfrow=c(1,1))
}
conditions = c('N','S')
samples <- sample.names[sample.condition == cond]
for (cond in conditions) {
}
samples <- sample.names[sample.condition == cond]
samples
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c(sample[1], sample[2])])
plot(counts[, c(sample[1], sample[3])])
plot(counts[, c(sample[2], sample[3])])
}
par(mfrow=c(1,1))
samples <- sample.names[sample.condition == cond]
plot(counts[, c(sample[1], sample[2])])
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])])
plot(counts[, c(samples[1], samples[3])])
plot(counts[, c(samples[2], samples[3])])
}
par(mfrow=c(1,1))
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])], panel.first=grid(), col="gray")
plot(counts[, c(samples[1], samples[3])], panel.first=grid(), col="gray")
plot(counts[, c(samples[2], samples[3])], panel.first=grid(), col="gray")
}
par(mfrow=c(1,1))
cond
plot(counts[, c(samples[1], samples[2])], panel.first=grid(), col=colors.per.condition[cond])
colors.per.condition <- c("N" = "#BBBBFF",
"S" = "#FFFF00",
"NN" = "#00BBBB",
"SN" = "#00BBBB"
)
plot(counts[, c(samples[1], samples[2])], panel.first=grid(), col=colors.per.condition[cond])
colors.per.condition <- c("N" = "#BBBBFF",
"S" = "#BBBB00",
"NN" = "#00BBBB",
"SN" = "#00BBBB"
)
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])], panel.first=grid(), col=colors.per.condition[cond])
plot(counts[, c(samples[1], samples[3])], panel.first=grid(), col=colors.per.condition[cond])
plot(counts[, c(samples[2], samples[3])], panel.first=grid(), col=colors.per.condition[cond])
colors.per.condition <- c("N" = "#BBBBFF",
"S" = "#BB8800",
"NN" = "#00BBBB",
"SN" = "#00BBBB"
)
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])], panel.first=grid(), col=colors.per.condition[cond])
plot(counts[, c(samples[1], samples[3])], panel.first=grid(), col=colors.per.condition[cond])
plot(counts[, c(samples[2], samples[3])], panel.first=grid(), col=colors.per.condition[cond])
cond <- "N"
plot(counts[, c(samples[1], samples[2])], panel.first=grid(), col=colors.per.condition[cond])
colors.per.condition <- c("N" = "#4488FF",
"S" = "#BB8800",
"NN" = "#00BBBB",
"SN" = "#00BBBB"
plot(counts[, c(samples[1], samples[3])], panel.first=grid(), col=colors.per.condition[cond])
colors.per.condition <- c("N" = "#4488FF",
"S" = "#BB8800",
"NN" = "#00BBBB",
"SN" = "#00BBBB"
)
plot(counts[, c(samples[1], samples[2])], panel.first=grid(), col=colors.per.condition[cond])
colors.per.condition <- c("N" = "#66BBFF",
"S" = "#BB8800",
"NN" = "#00BBBB",
"SN" = "#00BBBB"
)
plot(counts[, c(samples[1], samples[2])], panel.first=grid(), col=colors.per.condition[cond])
colors.per.condition <- c("N" = "#66BBFF",
"S" = "#BB8800",
"NN" = "#FF00BB",
"SN" = "#FFBB00"
)
counts
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])], panel.first=grid(), col=colors.per.condition[cond], log="xy")
plot(counts[, c(samples[1], samples[3])], panel.first=grid(), col=colors.per.condition[cond], log="xy")
plot(counts[, c(samples[2], samples[3])], panel.first=grid(), col=colors.per.condition[cond], log="xy")
}
par(mfrow=c(1,1))
samples[1]
stats.per.sample
stats.per.sample[samples[1],]
stats.per.sample[samples[1],"sum"]
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])],
xlab=paste(sample[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(sample[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
panel.first=grid(), col=colors.per.condition[cond],
)
plot(counts[, c(samples[1], samples[3])],
xlab=paste(sample[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(sample[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond],
)
plot(counts[, c(samples[2], samples[3])],
xlab=paste(sample[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
ylab=paste(sample[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond],
)
}
par(mfrow=c(1,1))
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
panel.first=grid(), col=colors.per.condition[cond],
)
plot(counts[, c(samples[1], samples[3])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond],
)
plot(counts[, c(samples[2], samples[3])],
xlab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond],
)
}
par(mfrow=c(1,1))
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
panel.first=grid(), col=colors.per.condition[cond]
)
plot(counts[, c(samples[1], samples[3])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond]
)
plot(counts[, c(samples[2], samples[3])],
xlab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond]
)
}
par(mfrow=c(1,1))
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
panel.first=grid(), col=colors.per.condition[cond], log="xy"
)
plot(counts[, c(samples[1], samples[3])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond], log="xy"
)
plot(counts[, c(samples[2], samples[3])],
xlab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond], log="xy"
)
}
par(mfrow=c(1,1))
ablines()
abline(v=stats.per.sample[samples[1],"Q3"])
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
panel.first=grid(), col=colors.per.condition[cond], log="xy"
)
abline(v=stats.per.sample[samples[1],"Q3"])
abline(h=stats.per.sample[samples[2],"Q3"])
plot(counts[, c(samples[1], samples[3])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond], log="xy"
)
plot(counts[, c(samples[2], samples[3])],
xlab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond], log="xy"
)
}
par(mfrow=c(1,1))
abline(v=stats.per.sample[samples[1],c("Q1", "median" "Q3"], lty=c("dashed", "solid", "dashed")
abline(v=stats.per.sample[samples[1],c("Q1", "median", "Q3"], lty=c("dashed", "solid", "dashed")
abline(v=stats.per.sample[samples[1],c("Q1", "median", "Q3"), lty=c("dashed", "solid", "dashed"))
abline(v=stats.per.sample[samples[1],c("Q1", "median", "Q3"), lty=c("dashed", "solid", "dashed")])
abline(v=stats.per.sample[samples[1],c("Q1", "median", "Q3"), type=c("dashed", "solid", "dashed")])
abline(v=stats.per.sample[samples[1],c("Q1", "median", "Q3")], type=c("dashed", "solid", "dashed"))
abline(v=stats.per.sample[samples[1],c("Q1", "median", "Q3")], lty=c("dashed", "solid", "dashed"))
abline(v=stats.per.sample[samples[1],c("Q1", "median", "Q3")])
source("data/1258-BRM/results/N_VS_S_bowtie2_mm1_sorted_name_params.R")
## setwd("../../") ## Only for testing when the test starts from the scripts directory
## Temporary: set up manually the files and folder.
## We will later improve this by reading the config file from arguments (argv)
source("data/1258-BRM/results/N_VS_S_bowtie2_mm1_sorted_name_params.R")
dir.main <- "."
## Create a specific result directory for this differential analysis
dir.results <- file.path(dir.main, "results", "DEG", paste(sep="", cond1, "_vs_", cond2))
dir.create(path = dir.results, showWarnings = FALSE, recursive = TRUE)
dir.figures <- file.path(dir.results, "figures")
dir.create(path = dir.figures, showWarnings = FALSE, recursive = TRUE)
# Read data from counts files
counts <- readDGE(counts.f)$counts
# Remove summary lines from HTseq files
#noint <- rownames(counts) %in% c("no_feature","ambiguous","too_low_aQual", "not_aligned","alignment_not_unique")
info.rows <- rownames(counts) %in% grep(rownames(counts),
pattern = "__",
value = TRUE)
# Remove all features that have less than 1 reads per millions of reads
cpms <- cpm(counts)                               ## Counts per million reads
## Only keep genes detected in at least n.rep samples, where n.rep is the number of replicates
keep <- (rowSums(cpms > 1) >= n.rep) & !info.rows
counts <- counts[keep,]
# Preparation of tables
colnames(counts) <- sample.names
## Set global options for R chunks
knitr::opts_chunk$set(eval=TRUE, cache=FALSE, echo=FALSE)
## Load required librarires
library("edgeR")
library("limma")
library("xtable")
library("knitr")
colors.per.condition <- c("N" = "#66BBFF",
"S" = "#BB8800",
"NN" = "#FF00BB",
"SN" = "#FFBB00"
)
## setwd("../../") ## Only for testing when the test starts from the scripts directory
## Temporary: set up manually the files and folder.
## We will later improve this by reading the config file from arguments (argv)
source("data/1258-BRM/results/N_VS_S_bowtie2_mm1_sorted_name_params.R")
dir.main <- "."
## Create a specific result directory for this differential analysis
dir.results <- file.path(dir.main, "results", "DEG", paste(sep="", cond1, "_vs_", cond2))
dir.create(path = dir.results, showWarnings = FALSE, recursive = TRUE)
dir.figures <- file.path(dir.results, "figures")
dir.create(path = dir.figures, showWarnings = FALSE, recursive = TRUE)
# Read data from counts files
counts <- readDGE(counts.f)$counts
# Remove summary lines from HTseq files
#noint <- rownames(counts) %in% c("no_feature","ambiguous","too_low_aQual", "not_aligned","alignment_not_unique")
info.rows <- rownames(counts) %in% grep(rownames(counts),
pattern = "__",
value = TRUE)
# Remove all features that have less than 1 reads per millions of reads
cpms <- cpm(counts)                               ## Counts per million reads
## Only keep genes detected in at least n.rep samples, where n.rep is the number of replicates
keep <- (rowSums(cpms > 1) >= n.rep) & !info.rows
counts <- counts[keep,]
# Preparation of tables
colnames(counts) <- sample.names
setwd("~/no-stress_project") ## Only for testing when the test starts from the scripts directory
## Temporary: set up manually the files and folder.
## We will later improve this by reading the config file from arguments (argv)
source("data/1258-BRM/results/N_VS_S_bowtie2_mm1_sorted_name_params.R")
## Set global options for R chunks
knitr::opts_chunk$set(eval=TRUE, cache=FALSE, echo=FALSE)
## Set main directory
dir.main <- "~/no-stress_project"
setwd(dir.main)
## Load required librarires
library("edgeR")
library("limma")
library("xtable")
library("knitr")
## Set global options for R chunks
knitr::opts_chunk$set(eval=TRUE, cache=FALSE, echo=FALSE)
## Set main directory
dir.main <- "~/no-stress_project"
setwd(dir.main)
## Load required librarires
library("edgeR")
library("limma")
library("xtable")
library("knitr")
## The count table must have been loaded prior to the execution of this script
stats.per.sample <- data.frame(
min = apply(counts, 2, min),             ## Minimal count number (percentile 0)
p05 = apply(counts, 2, quantile, 0.05),  ## 5th percentile
Q1 = apply(counts, 2, quantile, 0.25),   ## 1st quartile (percentile 25)
median = apply(counts, 2, median),       ## Median (percentile 50)
Q3 = apply(counts, 2, quantile, 0.75),   ## Third quartile (percentile 75)
p95 = apply(counts, 2, quantile, 0.95),  ## Percentile 95
max = apply(counts, 2, max),             ## Maximum (percentile 100)
sum = apply(counts, 2, sum)              ## Sum of counts
)
stats.per.sample$relative.size <- stats.per.sample$sum / min(stats.per.sample$sum)
stats.per.sample$condition <- sample.condition
kable(stats.per.sample, format = "markdown", digits=2)
abline(v=stats.per.sample[samples[1],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
## Set global options for R chunks
knitr::opts_chunk$set(eval=TRUE, cache=FALSE, echo=FALSE)
## Load required librarires
library("edgeR")
library("limma")
library("xtable")
library("knitr")
## Define colors for the plots
colors.per.condition <- c("N" = "#66BBFF",
"S" = "#BB8800",
"NN" = "#FF00BB",
"SN" = "#FFBB00"
)
## Set main directory
dir.main <- "~/no-stress_project"
setwd(dir.main)
## Temporary: set up manually the files and folder.
## We will later improve this by reading the config file from arguments (argv)
source("data/1258-BRM/results/N_VS_S_bowtie2_mm1_sorted_name_params.R")
## Create a specific result directory for this differential analysis
dir.results <- file.path(dir.main, "results", "DEG", paste(sep="", cond1, "_vs_", cond2))
dir.create(path = dir.results, showWarnings = FALSE, recursive = TRUE)
dir.figures <- file.path(dir.results, "figures")
dir.create(path = dir.figures, showWarnings = FALSE, recursive = TRUE)
# Read data from counts files
counts <- readDGE(counts.f)$counts
# Remove summary lines from HTseq files
#noint <- rownames(counts) %in% c("no_feature","ambiguous","too_low_aQual", "not_aligned","alignment_not_unique")
info.rows <- rownames(counts) %in% grep(rownames(counts),
pattern = "__",
value = TRUE)
# Remove all features that have less than 1 reads per millions of reads
cpms <- cpm(counts)                               ## Counts per million reads
## Only keep genes detected in at least n.rep samples, where n.rep is the number of replicates
keep <- (rowSums(cpms > 1) >= n.rep) & !info.rows
counts <- counts[keep,]
# Preparation of tables
colnames(counts) <- sample.names
## The count table must have been loaded prior to the execution of this script
stats.per.sample <- data.frame(
min = apply(counts, 2, min),             ## Minimal count number (percentile 0)
p05 = apply(counts, 2, quantile, 0.05),  ## 5th percentile
Q1 = apply(counts, 2, quantile, 0.25),   ## 1st quartile (percentile 25)
median = apply(counts, 2, median),       ## Median (percentile 50)
Q3 = apply(counts, 2, quantile, 0.75),   ## Third quartile (percentile 75)
p95 = apply(counts, 2, quantile, 0.95),  ## Percentile 95
max = apply(counts, 2, max),             ## Maximum (percentile 100)
sum = apply(counts, 2, sum)              ## Sum of counts
)
stats.per.sample$relative.size <- stats.per.sample$sum / min(stats.per.sample$sum)
stats.per.sample$condition <- sample.condition
kable(stats.per.sample, format = "markdown", digits=2)
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
panel.first=grid(), col=colors.per.condition[cond]
)
#   abline(v=stats.per.sample[samples[1],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
#   abline(h=stats.per.sample[samples[2],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
plot(counts[, c(samples[1], samples[3])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond]
)
#   abline(v=stats.per.sample[samples[1],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
#   abline(h=stats.per.sample[samples[3],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
plot(counts[, c(samples[2], samples[3])],
xlab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond]
)
#   abline(v=stats.per.sample[samples[2],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
#   abline(h=stats.per.sample[samples[3],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
}
par(mfrow=c(1,1))
par(mfrow=c(2,3))
for (cond in conditions) {
samples <- sample.names[sample.condition == cond]
plot(counts[, c(samples[1], samples[2])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
panel.first=grid(), col=colors.per.condition[cond], log="xy"
)
abline(v=stats.per.sample[samples[1],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
abline(h=stats.per.sample[samples[2],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
plot(counts[, c(samples[1], samples[3])],
xlab=paste(samples[1], ", count sum =", stats.per.sample[samples[1],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond], log="xy"
)
abline(v=stats.per.sample[samples[1],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
abline(h=stats.per.sample[samples[3],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
plot(counts[, c(samples[2], samples[3])],
xlab=paste(samples[2], ", count sum =", stats.per.sample[samples[2],"sum"]),
ylab=paste(samples[3], ", count sum =", stats.per.sample[samples[3],"sum"]),
panel.first=grid(), col=colors.per.condition[cond], log="xy"
)
abline(v=stats.per.sample[samples[2],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
abline(h=stats.per.sample[samples[3],c("p05", "Q1", "median", "Q3", "p95")], lty=c("dotted", "dashed", "solid", "dashed", "dottted"))
}
par(mfrow=c(1,1))
