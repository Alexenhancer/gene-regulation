---
title: "RNA-seq differential analysis report - Beatrice Roche"
output:
  html_document:
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  word_document: default
date: '`r Sys.Date()`'
---

```{r knitr setup, include=FALSE,  eval=TRUE, echo=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo=FALSE, eval=TRUE, cache=FALSE, message=FALSE, warning=FALSE)
```


```{r Loading R libraries, warning=FALSE}
library("stats4bioinfo") ## Generic library from Jacques van Helden
library("edgeR", warn.conflicts = FALSE, quietly=TRUE) ## Differential expression with RNA-seq
library("DESeq2", warn.conflicts = FALSE, quietly=TRUE, verbose=FALSE) ## Differential expression with RNA-seq
library("limma", warn.conflicts = FALSE, quietly=TRUE) ## Required for vennCounts and vennDiagram
library(gplots, warn.conflicts = FALSE, quietly=TRUE) ## Required for heatmaps.2
library(RColorBrewer, warn.conflicts = FALSE, quietly=TRUE)
library("GenomicFeatures")
```

<!-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
PROJECT-SPECIFIC PARAMETERS: THIS PART SHOULD BE ADAPTER FOR EACH PROJECT -->

## Project information

| Project Info |  |
|--------------|-------------------------|
| Customer  | Beatrice Roche
| Platform | TGML/TAGC, Marseille, France
| Bioinfo/stat analysis | Jacques van Helden
| Project start | 2015
| Last update | `r Sys.Date()`

```{r Required parameters}

## In this chunk we define the project-specific parameters that are required to enable an analysis. Other (optional) parameters can be defined below to customize the thresholds, figure styles, ... 
dir.fg <- "~/fg-chip-seq/" ## Directory containing routines from France Génomique

## Load a library with the utilities
source(file.path(dir.fg, "scripts/R-scripts/deg_lib.R"))

## base directory for the report (links are defined relative to this directory)
dir.base <- "~/BeatriceRoche/reports/" 
setwd(dir.base)

################################################################
## Input parameters

## Sample description file (one row per sample)
sample.description.file <- "../data/broche_samples.tab"

## Dsign file (pairs of samples to be compared)
design.file <- "../data/broche_analyses.tab"

## Table containing the counts of reads per gene (rows) for each sample (columns) 
all.counts.table <- '../results/DEG/sickle_pe_q20_bowtie2_pe_sorted_name_all_counts.tab'

## The GTF file contains genomic annotations for the selected species
organism.name <- "Escherichia coli"
gtf.file <- "../genome/Escherichia_coli_str_k_12_substr_mg1655.GCA_000005845.2.28.gtf"
gtf.source <- "ftp://ftp.ensemblgenomes.org/pub/bacteria/release-28/fasta/bacteria_0_collection/escherichia_coli_str_k_12_substr_mg1655/"

################################################################
## Output parameters
dir.DEG <-'../results/DEG' ## Output directory (relative to base dir)
dir.figures <- file.path(dir.DEG, "figures")
dir.create(dir.figures, showWarnings = FALSE, recursive = TRUE)
suffix.deg <- 'sickle_pe_q20_bowtie2_pe_sorted_name' ## Suffix for the output files

## Prefix for output files concerning the whole count table (all samples together)
## prefix["general.file"] <- sub(pattern = ".tab", replacement="", all.counts.table)
prefix <- vector()
prefix["general.file"] <- file.path(dir.DEG, suffix.deg)
prefix["general.file"] <- file.path(dir.DEG, suffix.deg) ## Path prefix for the general files

################################################################
## Thresholds for differential analysis. 

thresholds <- c("padj"=0.05, ## Upper threshold on False Discovery Rate (FDR)
                "evalue"=1, ## Upper threshold on the expected number of false positives
                "FC"=1.5 ## Lower threshold on the fold-change
                )

```

<!-- END OF THE PROJECT-SPECIFIC PARAMETERS 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -->

```{r Default parameters}
## In this chunk, we define a set of default parameters for the display and the analysis. 
## These parameters can be modified but it is not necessary to adapt them to each project.

verbosity <- 0

## Color palette for heatmaps. I like this Red-Blue palette because 
## - it suggests a subjective feeling of warm (high correlation)/cold (low correlation)
## - it can be seen by people suffering from red–green color blindness.
cols.heatmap <- rev(colorRampPalette(brewer.pal(9,"RdBu"))(100))

## A trick: to enable log-scaled plots for 0 values, I add an epsilon increment
epsilon <- 0.01
```


```{r Load gene information from GTF file, warning=FALSE, echo=FALSE}
################################################################
## Load gene information from the GTF file 
## (should be the same as used to count tags per gene)

if (exists("gtf.file")) {
  
  ## Jacques or Lucie, TO DO : check if the method makeTxDbFromGFF allows to get gene names and descriptions.
  ## In principle it should be possible since this info is in the GTF file. 
  ## If not, we migh rewite a parser for GTF. 
  
  verbose(paste("Loading gene annotations from GTF file: ", gtf.file), 2)
  #   library(rtracklayer)  # for the import() function
  #   gr <- import(gtf.file)
  txdb <- makeTxDbFromGFF(file=gtf.file,
                          organism=organism.name,
                          dataSource=gtf.source)
  #seqlevels(txdb)
  #   transcripts <- transcriptsBy(txdb, by="gene")
  #   transcript.table <- as.data.frame(transcripts@unlistData)
  #   cds <- cdsBy(txdb, by="gene")
  #   cds.table <- as.data.frame(cds@unlistData)
  #   exons <- exonsBy(txdb, by="gene")
  #   exon.table <- as.data.frame(exons@unlistData)
  all.genes <- genes(txdb)
  gene.info <- as.data.frame(all.genes)
  gene.info$name <- gene.info$gene_id
  gene.info$entrez.id <- NA
  gene.info$description <- "no description"
} else {
  verbose(paste("No GTF file has been specified"))
  g <- nrow(all.counts)
  gene.info <- data.frame("seqnames"=rep(NA, times=g),
                          "start"=rep(NA, times=g),
                          "end"=rep(NA, times=g),
                          "width"=rep(NA, times=g),
                          "strand"=rep(NA, times=g),
                          "gene_id"=row.names(all.counts),
                          "name"=row.names(all.counts),
                          "entrez.id" = rep(NA, times=g),
                          "description"=rep("no description", times=g))
  row.names(gene.info) <- row.names(all.counts)
}
# View(gene.info)

## Export the gene information table to keep a trace of what has been used. 
gene.info.out <- paste(sep="", prefix["general.file"], "_gene_descriptions.tab")
verbose(paste("Exporting gene information table", gene.info.out), 1)
write.table(x = gene.info, row.names = FALSE,
            file = gene.info.out, sep = "\t", quote=FALSE)
verbose(paste(sep="", "\tGene info table\t", gene.info.out), 1)


```


## Parameters

| Parameter | Value |
|-----------|-------|
| Sample descriptions | [`r sample.description.file`](`r sample.description.file`) |
| Analyses descriptions | [`r design.file`](`r design.file`) |
| Thresholds | E-value $\le$ `r thresholds["evalue"]`; <br>Adjusted p-value (FDR) $\le$ `r thresholds["padj"]`; <br>Fold-change $\ge$ `r thresholds["FC"]`|



## Samples


```{r Read sample description and define condition-specific parameters}

## Read the sample description file, which indicates the 
## condition associated to each sample ID.
verbose(paste("Reading sample description file: ", sample.description.file), 2)
sample.desc <- read.delim(sample.description.file, sep="\t", 
                          comment=";", header = TRUE, row.names=1)
sample.ids <- row.names(sample.desc)

## Experimental conditions
sample.conditions <- as.vector(sample.desc[,1]) ## Condition associated to each sample
names(sample.conditions) <- sample.ids
# print(sample.conditions)

## Build sample labels by concatenating their ID and condition
sample.desc$label <- paste(sep="_", sample.ids, sample.conditions)

## Define a specific color for each distinct condition
conditions <- unique(sample.conditions) ## Set of distinct conditions
cols.conditions <- brewer.pal(max(3, length(conditions)),"Dark2")[1:length(conditions)]
names(cols.conditions) <- conditions
# print(cols.conditions)

## Define a color per sample according to its condition
sample.desc$color <- cols.conditions[sample.conditions]
# names(cols.samples) <- sample.ids
# print(cols.samples)
```



<!-- TO DO: PRINT TABLE WITH SAMPLE IDS PER CONDITION -->



```{r Loading count table}
################################################################
## Read the count table
verbose("Loading count table", 2)
all.counts <- read.delim(all.counts.table, row.names=1, sep="\t")
# names(all.counts)
# dim(all.counts)

## Check that the header of all.counts match the sample IDs
ids.not.found <- setdiff(sample.ids, names(all.counts)) ## Identify sample IDs with no column in the count table
if (length(ids.not.found) > 0) {
  stop(paste(length(ids.not.found), "Missing columns in count table", all.counts.table), paste(sep="; ", ids.not.found))
}

################################################################
## Restrict the count table to the sample IDs found in the sample description file
all.counts <- all.counts[, sample.ids]
# names(all.counts)
# dim(all.counts)

########################################################################
## Treatment of 0 values.
## Add an epsilon to 0 values only, in order to enable log-transform and display on logarithmic axes.
verbose(paste("Treating zero-values by adding epsilon =", epsilon), 2)
all.counts.epsilon <- all.counts
all.counts.epsilon[all.counts==0] <- epsilon

## Log-transformed data for some plots. 
all.counts.log10 <- log10(all.counts.epsilon)

```

### Sample-wise statistics

The raw counts table ([`r all.counts.table`](`r all.counts.table`)) contains `r nrow(all.counts)` rows (features, genes) and `r ncol(all.counts)` columns (conditions, samples).


```{r Sample-wise statistics}
################################################################
## Compute sample-wise statistics on mapped counts
################################################################
stats.per.sample <- calc.stats.per.sample(sample.desc, all.counts)

################################################################
## Compute the counts per million reads 
################################################################
verbose("Computing CPMs", 1)
## Note: the default normalization criterion (scaling by libbrary sum) 
## is questionable because it is stronly sensitive to outliers 
## (very highly expressed genes).  A more robust normalisation criterion 
## is to use the 75th percentile, or the median. We use the median, somewhat arbitrarily, 
## beause it gives a nice alignment on the boxplots.
cpms.libsum <- cpm(all.counts.epsilon)    ## Counts per million reads, normalised by library sum
cpms.perc75 <- cpm(all.counts.epsilon, lib.size = stats.per.sample$perc75)    ## Counts per million reads, normalised by 75th percentile
cpms.perc95 <- cpm(all.counts.epsilon, lib.size = stats.per.sample$perc95)    ## Counts per million reads, normalised by 95th percentile
cpms.median <- cpm(all.counts.epsilon, lib.size = stats.per.sample$median)    ## Counts per million reads, normalised by sample-wise median count
#cpms <- cpms.median ## Choose one normalization factor for the CPMs used below
cpms <- cpms.perc75 ## Choose one normalization factor for the CPMs used below
cpms.log10 <- log10(cpms) ## Log-10 transformed CPMs, with the epsilon for 0 counts
cpms.log2 <- log2(cpms) ## Log-10 transformed CPMs, with the epsilon for 0 counts

## Compute Trimmed Means of M Values (TMM): TO BE DONE
stats.per.sample$cpm.mean <- apply(cpms, 2, mean)
stats.per.sample$log2.cpm.mean <- apply(cpms.log2, 2, mean)
stats.per.sample$log10.cpm.mean <- apply(cpms.log10, 2, mean)

################################################################
## Export stats per sample
#
# names(stats.per.sample)
# head(stats.per.sample)
verbose("Exporting stats per sample", 1)
sample.summary.file <- paste(sep="", prefix["general.file"], "_summary_per_sample.tab")
write.table(x = stats.per.sample, row.names = TRUE, col.names=NA, 
            file = sample.summary.file, sep = "\t", quote=FALSE)
verbose(paste(sep="", "\tSummary per sample\t", sample.summary.file), 1)
```

### Sample sizes

```{r library_sizes_barplot, fig.width=6, fig.height=6, fig.cap="Library size barplot. Bars indicate the sum of read counts per sample (library)."}
libsize.barplot(stats.per.sample, plot.file=NULL)
```


### Read count distributions

```{r count_boxplots, fig.width=10, fig.height=10, fig.cap="Read count distributions. Top: raw counts. Bottom: counts per millon reads (CPMs). Left panels: linear scale, which emphasizes  outlier features denoted by very high counts. Rigt panels log counts permit to perceive the distribution of its whole range, including small count values. Null counts are replaced by an epsilon < 1, and appearas negative numbers after log transformation."}
par(mfrow=c(2,2))
  ## Boxplot of raw counts
  count.boxplot(all.counts, stats.per.sample, xlab="Raw counts", 
                main="Raw counts per sample")

  ## Boxplot of log10-transformed counts
  count.boxplot(all.counts.log10, stats.per.sample, xlab="log10(counts)", 
                main="log10(counts) per sample")

  ## Boxplot of CPMs
  count.boxplot(cpms, stats.per.sample, xlab="CPM", 
                main="CPMs per sample")
  
  ## Boxplot of log10-transformed CPMs
  count.boxplot(cpms.log10, stats.per.sample, xlab="log10(CPM)", 
                main="log10(CPMs) per sample")
par(mfrow=c(1,1))
```


### Count correlations between samples

Note: count correlations from raw rads are highly impacted by outlier features. 
<font color="red">TO DO</font>
I should adapt the method to trim the upper and lower count values.

```{r count_correl_heatmap, fig.width=8, fig.height=8}
count.correl.heatmap(all.counts)
```


## Between-replicate reproducibility

Between-replicate count comparisons highlight the general reproducibility of the experiment. In some cases they reveal a strong variability of some particular features, which appear very distant from the diagonal. 

<font color="RED">TO DO</font>
I should develop a method to tag the irreproducible features and/or filter them out from the lists of DEG. 

```{r between-replicate_reproducibility, fig.width=10, fig.height=10, fig.cap="Each plot shows the reproducibility between replicates of a given condition."}

################################################################
## Analyse between-replicate reproducibility
################################################################
verbose("Plotting betwen-replicate comparisons", 2)
#conditions.with.replicate <- setdiff(conditions, "CI_CI_0H")
cond <- conditions[1] ## Choose first condition for testing without the loop
for (cond in conditions) {
#for (cond in conditions.with.replicate) {
  verbose(paste(sep="", "\tcondition\t", cond), 3)
  
  min.rep.to.plot <- 2 ## Not worth plotting replicates for conditions without replicate
  max.rep.to.plot <- 5 ## Restrict the number of replicates to plot, for the sale of readability
  
  ## Create a specific result directory for this condition
  dir.condition <- file.path(dir.DEG, "per_condition", cond)
  dir.create(path = dir.condition, showWarnings = FALSE, recursive = TRUE)
  
  ## Select the specific data for the current condition (samples, counts, CPMs)
  #all.counts.with.replicate <- setdiff(names(all.counts), "CI_CI_0H_1")
  current.samples <- names(all.counts)[sample.conditions == cond]
  nrep <- length(current.samples)

  current.counts <- all.counts[,current.samples]
  current.counts[current.counts==0] <- epsilon
  current.counts.mean <- apply(current.counts, 1, mean)
  current.counts.var <- apply(current.counts, 1, var)
  current.counts.var[current.counts.var==0] <- min(current.counts.var[current.counts.var>0])/100
  
  current.cpms <- cpms[,current.samples] + epsilon
  current.cpms[current.cpms==0] <- epsilon
  current.cpm.mean <- apply(current.cpms, 1, mean)
  current.cpm.var <- apply(current.cpms, 1, var)
  current.cpm.var[current.cpm.var==0] <- min(current.cpm.var[current.cpm.var>0])/100
  
  ################################################################
  ## Plot pairwise comparisons between replicates (result file can be heavy to open)
#   pdf(file= file.path(dir.condition, paste(sep = "", "between-replicate_counts_plot_", cond, ".pdf")), width=10, height=10)
#   # dim(current.counts[,1:min(max.rep.to.plot, nrep)])
  plot(current.counts[,1:min(max.rep.to.plot, nrep)], 
       log="xy", col=cols.conditions[cond], 
#       panel.first=grid(col="#BBBBBB", lty="solid"), ## this does not work, I should check why
       main=paste(cond, " ; raw counts per replicate (log scale)")
  )
#  silence <- dev.off()
  
#   ################################################################
#   ## Plot mean versus variance of CPMs for the current condition.
#   ## BEWARE! This is the between-replicate variance computed for each gene separately, 
#   ## which is quite different from the smoothed estimate of variance used by 
#   ## DESeq2 or edgeR for the negative binomial.
#   ## 
#   ## This "real" variance plot  can be useful to highlight some genes that show 
#   ## an extremely high variance compared to other genes. 
#   ##
#   ## We draw the plot in linear + log scales. Linear scales better highlight the outliers, 
#   ## log scale better shows the general distribution, which covers several orders of magnitude.
#   log.axes <- "xy"
#   for (log.axes in c("", "xy")) {
# #     pdf(file= file.path(dir.condition, paste(sep = "", "CPM_variance-mean_plot_", cond, "_",  log.axes, ".pdf")), width=10, height=10)
#     plot(current.cpm.mean, 
#          current.cpm.var, 
#          log=log.axes, col=cols.conditions[cond], 
#          panel.first=grid(lty="solid", col="#DDDDDD"),
#          xlab=paste("Mean CPM per gene for condition", cond),
#          ylab=paste("Between replicate CPM variance per gene for condition", cond),
#          main=paste(cond, " ; CPM variance/Mean plot"))
#     abline(a=0,b=1, lty="dashed", col="green", lwd=2) ## Milestone for Poisson distributions: var = mean
#     # silence <- dev.off() 
#   }
}

```


## Detection of differentially expressed genes

### Design

```{r Read the design, warning=FALSE}

## Read the design file, which indicates the anlayses to be done.
## Each row specifies one differential expression analysis, which 
## consists in comparing two conditions. 
verbose(paste("Reading design file: ", design.file), 2)
design <- read.delim(design.file, sep="\t", 
                     comment=";", header = T, row.names=NULL)
```

<!-- TO DO: print a table with the design -->


```{r}
i <- 1
comparison.results <- design ## Initialize a summary table for each DEG analysis
comparison.results$prefixes <- paste(sep="_", design$cond1, "vs", design$cond2)

for (i in 1:nrow(design)) {
  ## Identify samples for the first condition
  cond1 <- as.vector(design[i,1])  ## First condition for the current comparison
  samples1 <- sample.ids[sample.conditions == cond1]
   if (length(samples1) < 2) {
     stop(paste("Cannot perform differential analysis. The count table contains less than 2 samples for condition", cond1))
   }
  
  ## Identify samples for the second condition
  cond2 <- as.vector(design[i,2])  ## Second condition for the current comparison
  samples2 <- sample.ids[sample.conditions == cond2]
   if (length(samples2) < 2) {
     stop(paste("Cannot perform differential analysis. The count table contains less than 2 samples for condition", cond2))
   }
  
  verbose(paste(sep="", "\tDifferential analysis\t", i , "/", nrow(design), "\t", cond1, " vs ", cond2), 1)
  
  ## Create a specific result directory for this differential analysis
  prefix["comparison"] <- comparison.results$prefixes[i]
  dir.analysis <- file.path(dir.DEG, paste(sep="", prefix["comparison"]))
  comparison.results$dir.analysis <- dir.analysis
  dir.create(path = dir.analysis, showWarnings = FALSE, recursive = TRUE)
  dir.figures <- file.path(dir.analysis, "figures")
  comparison.results$dir.figures <- dir.figures
  dir.create(path = dir.figures, showWarnings = FALSE, recursive = TRUE)
  prefix["comparison_file"] <- file.path(dir.analysis, prefix["comparison"])
  prefix["comparison_figure"] <- file.path(
    dir.figures, 
    paste(sep="", prefix["comparison"], "_",  suffix.deg))
  
  ## Select counts for the samples belonging to the two conditions
  current.samples <- c(samples1, samples2)
  current.counts <- all.counts[,current.samples]
  # dim(current.counts)  ## For test
  # names(current.counts)
  
  if (sum(!names(current.counts) %in% sample.ids) > 0) {
    stop("Count table contains column names without ID in sample description file.")
  }
  
  ## Define conditions and labels for the samples of the current analysis
  current.sample.conditions <- sample.conditions[current.samples]
  current.labels <- paste(current.sample.conditions, names(current.counts), sep="_")
  
  ## Initiate a result table with the CPMs and derived statistics
  all.gene.ids <- row.names(cpms)
  result.table <- data.frame("gene_id" = all.gene.ids,
                             "name"=gene.info[all.gene.ids,"name"])
  row.names(result.table) <- all.gene.ids
  result.table$entrez.id <- gene.info[all.gene.ids,"entrez.id"]
  result.table$description <- gene.info[all.gene.ids,"description"]
  
  result.table <- cbind(result.table, counts=current.counts) ## Include the original counts in the big result table
  result.table <- cbind(result.table, cpm=current.cpms) ## Include CPMs in the big result table
  
  ## Tag genes detected in less than min.rep samples, which is defined as 
  ## the minimal number of replicates per condition.
  min.rep <- min(length(samples1), length(samples2))
  result.table$undetected <- rowSums(current.counts > 1) < min.rep
  # table(result.table$undetected)
  # dim(current.counts)
  
  result.table$cpm.mean <- apply(cpms,1, mean)
  result.table$cpm1.mean <- apply(as.data.frame(cpms[,samples1]),1, mean)
  result.table$cpm2.mean <- apply(as.data.frame(cpms[,samples2]),1, mean)
  result.table$A = log2(result.table$cpm1.mean*result.table$cpm2.mean)/2
  result.table$M = log2(result.table$cpm1.mean/result.table$cpm2.mean)
  result.table$cpm.median <- apply(cpms,1, median)
  result.table$cpm1.median <- apply(as.data.frame(cpms[,samples1]),1, median)
  result.table$cpm2.median <- apply(as.data.frame(cpms[,samples2]),1, median)
  result.table$cpm.min <-  apply(cpms,1, min)
  result.table$cpm1.min <- apply(as.data.frame(cpms[,samples1]),1, min)
  result.table$cpm2.min <- apply(as.data.frame(cpms[,samples2]),1, min)
  result.table$cpm.max <-  apply(cpms,1, max)
  result.table$cpm1.max <- apply(as.data.frame(cpms[,samples1]),1, max)
  result.table$cpm2.max <- apply(as.data.frame(cpms[,samples2]),1, max)
  result.table$cpm.sd <-  apply(cpms,1, sd)
  result.table$cpm1.sd <- apply(as.data.frame(cpms[,samples1]),1, sd)
  result.table$cpm2.sd <- apply(as.data.frame(cpms[,samples2]),1, sd)
  result.table$cpm.var <-  apply(cpms,1, var)
  result.table$cpm1.var <- apply(as.data.frame(cpms[,samples1]),1, sd)
  result.table$cpm2.var <- apply(as.data.frame(cpms[,samples2]),1, sd)
  # View(result.table)
}

```

* * * 

## Directories and files

### Input files

| Content   | File  |
|-----------|-------|
| Base directory | [`r dir.base`](`r dir.base`) |
| Raw counts | [`r all.counts.table`](`r all.counts.table`) |
| Gene annotations (GTF file) | [`r gtf.file`](`r gtf.file`) |

### Output files

| Content   | File  |
|-----------|-------|
| Output directory | [`r dir.DEG`](`r dir.DEG`) |
| Gene info table | [`r gene.info.out`](`r gene.info.out`) |
| Sample summary table | [`r sample.summary.file`](`r sample.summary.file`) |

* * *
