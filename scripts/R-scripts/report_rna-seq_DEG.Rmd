---
title: "RNA-seq differential analysis report - Beatrice Roche"
output:
  html_document:
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  word_document: default
date: '`r Sys.Date()`'
---

```{r knitr setup, include=FALSE,  eval=TRUE, echo=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo=FALSE, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE)
```


```{r Loading R libraries, warning=FALSE}
library("stats4bioinfo") ## Generic library from Jacques van Helden
library("edgeR", warn.conflicts = FALSE, quietly=TRUE) ## Differential expression with RNA-seq
library("DESeq2", warn.conflicts = FALSE, quietly=TRUE, verbose=FALSE) ## Differential expression with RNA-seq
library("limma", warn.conflicts = FALSE, quietly=TRUE) ## Required for vennCounts and vennDiagram
library(gplots, warn.conflicts = FALSE, quietly=TRUE) ## Required for heatmaps.2
library(RColorBrewer, warn.conflicts = FALSE, quietly=TRUE)
library("GenomicFeatures")
```

<!-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
PROJECT-SPECIFIC PARAMETERS: THIS PART SHOULD BE ADAPTER FOR EACH PROJECT -->

## Project information

| Project Info |  |
|--------------|-------------------------|
| Customer  | Beatrice Roche
| Platform | TGML/TAGC, Marseille, France
| Bioinfo/stat analysis | Jacques van Helden
| Project start | 2015
| Last update | `r Sys.Date()`

```{r Required parameters}

## In this chunk we define the project-specific parameters that are required to enable an analysis. Other (optional) parameters can be defined below to customize the thresholds, figure styles, ... 
dir.fg <- "~/fg-chip-seq/" ## Directory containing routines from France Génomique

## Load a library with the utilities
source(file.path(dir.fg, "scripts/R-scripts/deg_lib.R"))

## base directory for the report (links are defined relative to this directory)
dir.base <- "~/BeatriceRoche/reports/" 
setwd(dir.base)

################################################################
## Input parameters

## Sample description file (one row per sample)
sample.description.file <- "../data/broche_samples.tab"

## Dsign file (pairs of samples to be compared)
design.file <- "../data/broche_analyses.tab"

## Table containing the counts of reads per gene (rows) for each sample (columns) 
all.counts.table <- '../results/DEG/sickle_pe_q20_bowtie2_pe_sorted_name_all_counts.tab'

## The GTF file contains genomic annotations for the selected species
organism.name <- "Escherichia coli"
gtf.file <- "../genome/Escherichia_coli_str_k_12_substr_mg1655.GCA_000005845.2.28.gtf"
gtf.source <- "ftp://ftp.ensemblgenomes.org/pub/bacteria/release-28/fasta/bacteria_0_collection/escherichia_coli_str_k_12_substr_mg1655/"

################################################################
## Output parameters
dir.DEG <-'../results/DEG' ## Output directory (relative to base dir)
dir.figures <- file.path(dir.DEG, "figures")
dir.create(dir.figures, showWarnings = FALSE, recursive = TRUE)
suffix.deg <- 'sickle_pe_q20_bowtie2_pe_sorted_name' ## Suffix for the output files

## Prefix for output files concerning the whole count table (all samples together)
## prefix["general.file"] <- sub(pattern = ".tab", replacement="", all.counts.table)
prefix <- vector()
prefix["general.file"] <- file.path(dir.DEG, suffix.deg)
prefix["general.file"] <- file.path(dir.DEG, suffix.deg) ## Path prefix for the general files

################################################################
## Thresholds for differential analysis. 

thresholds <- c("padj"=0.05, ## Upper threshold on False Discovery Rate (FDR)
                "evalue"=1, ## Upper threshold on the expected number of false positives
                "FC"=1.5 ## Lower threshold on the fold-change
                )

```

<!-- END OF THE PROJECT-SPECIFIC PARAMETERS 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -->

```{r Default parameters}
## In this chunk, we define a set of default parameters for the display and the analysis. 
## These parameters can be modified but it is not necessary to adapt them to each project.

verbosity <- 0

## Color palette for heatmaps. I like this Red-Blue palette because 
## - it suggests a subjective feeling of warm (high correlation)/cold (low correlation)
## - it can be seen by people suffering from red–green color blindness.
cols.heatmap <- rev(colorRampPalette(brewer.pal(9,"RdBu"))(100))

## A trick: to enable log-scaled plots for 0 values, I add an epsilon increment
epsilon <- 0.01
```


```{r Load gene information from GTF file, warning=FALSE, echo=FALSE}
################################################################
## Load gene information from the GTF file 
## (should be the same as used to count tags per gene)

if (exists("gtf.file")) {
  
  ## Jacques or Lucie, TO DO : check if the method makeTxDbFromGFF allows to get gene names and descriptions.
  ## In principle it should be possible since this info is in the GTF file. 
  ## If not, we migh rewite a parser for GTF. 
  
  verbose(paste("Loading gene annotations from GTF file: ", gtf.file), 2)
  #   library(rtracklayer)  # for the import() function
  #   gr <- import(gtf.file)
  txdb <- makeTxDbFromGFF(file=gtf.file,
                          organism=organism.name,
                          dataSource=gtf.source)
  #seqlevels(txdb)
  #   transcripts <- transcriptsBy(txdb, by="gene")
  #   transcript.table <- as.data.frame(transcripts@unlistData)
  #   cds <- cdsBy(txdb, by="gene")
  #   cds.table <- as.data.frame(cds@unlistData)
  #   exons <- exonsBy(txdb, by="gene")
  #   exon.table <- as.data.frame(exons@unlistData)
  all.genes <- genes(txdb)
  gene.info <- as.data.frame(all.genes)
  gene.info$name <- gene.info$gene_id
  gene.info$entrez.id <- NA
  gene.info$description <- "no description"
} else {
  verbose(paste("No GTF file has been specified"))
  g <- nrow(all.counts)
  gene.info <- data.frame("seqnames"=rep(NA, times=g),
                          "start"=rep(NA, times=g),
                          "end"=rep(NA, times=g),
                          "width"=rep(NA, times=g),
                          "strand"=rep(NA, times=g),
                          "gene_id"=row.names(all.counts),
                          "name"=row.names(all.counts),
                          "entrez.id" = rep(NA, times=g),
                          "description"=rep("no description", times=g))
  row.names(gene.info) <- row.names(all.counts)
}
# View(gene.info)

## Export the gene information table to keep a trace of what has been used. 
gene.info.out <- paste(sep="", prefix["general.file"], "_gene_descriptions.tab")
verbose(paste("Exporting gene information table", gene.info.out), 1)
write.table(x = gene.info, row.names = FALSE,
            file = gene.info.out, sep = "\t", quote=FALSE)
verbose(paste(sep="", "\tGene info table\t", gene.info.out), 1)


```


## Parameters

| Parameter | Value |
|-----------|-------|
| Sample descriptions | [`r sample.description.file`](`r sample.description.file`) |
| Analyses descriptions | [`r design.file`](`r design.file`) |
| Thresholds | E-value $\le$ `r thresholds["evalue"]`; <br>Adjusted p-value (FDR) $\le$ `r thresholds["padj"]`; <br>Fold-change $\ge$ `r thresholds["FC"]`|



## Samples


```{r Read sample description and define condition-specific parameters}

## Read the sample description file, which indicates the 
## condition associated to each sample ID.
verbose(paste("Reading sample description file: ", sample.description.file), 2)
sample.desc <- read.delim(sample.description.file, sep="\t", 
                          comment=";", header = TRUE, row.names=1)
sample.ids <- row.names(sample.desc)

## Experimental conditions
sample.conditions <- as.vector(sample.desc[,1]) ## Condition associated to each sample
names(sample.conditions) <- sample.ids
# print(sample.conditions)

## Build sample labels by concatenating their ID and condition
sample.desc$label <- paste(sep="_", sample.ids, sample.conditions)

## Define a specific color for each distinct condition
conditions <- unique(sample.conditions) ## Set of distinct conditions
cols.conditions <- brewer.pal(max(3, length(conditions)),"Dark2")[1:length(conditions)]
names(cols.conditions) <- conditions
# print(cols.conditions)

## Define a color per sample according to its condition
sample.desc$color <- cols.conditions[sample.conditions]
# names(cols.samples) <- sample.ids
# print(cols.samples)
```



<!-- TO DO: PRINT TABLE WITH SAMPLE IDS PER CONDITION -->



```{r Loading count table}
################################################################
## Read the count table
verbose("Loading count table", 2)
all.counts <- read.delim(all.counts.table, row.names=1, sep="\t")
# names(all.counts)
# dim(all.counts)

## Check that the header of all.counts match the sample IDs
ids.not.found <- setdiff(sample.ids, names(all.counts)) ## Identify sample IDs with no column in the count table
if (length(ids.not.found) > 0) {
  stop(paste(length(ids.not.found), "Missing columns in count table", all.counts.table), paste(sep="; ", ids.not.found))
}

################################################################
## Restrict the count table to the sample IDs found in the sample description file
all.counts <- all.counts[, sample.ids]
# names(all.counts)
# dim(all.counts)

########################################################################
## Treatment of 0 values.
## Add an epsilon to 0 values only, in order to enable log-transform and display on logarithmic axes.
verbose(paste("Treating zero-values by adding epsilon =", epsilon), 2)
all.counts.epsilon <- all.counts
all.counts.epsilon[all.counts==0] <- epsilon

## Log-transformed data for some plots. 
all.counts.log10 <- log10(all.counts.epsilon)

```

### Sample-wise statistics

The raw counts table ([`r all.counts.table`](`r all.counts.table`)) contains `r nrow(all.counts)` rows (features, genes) and `r ncol(all.counts)` columns (conditions, samples).


```{r Sample-wise statistics}
################################################################
## Compute sample-wise statistics on mapped counts
################################################################
stats.per.sample <- calc.stats.per.sample(sample.desc, all.counts)

################################################################
## Compute the counts per million reads 
################################################################
verbose("Computing CPMs", 1)
## Note: the default normalization criterion (scaling by libbrary sum) 
## is questionable because it is stronly sensitive to outliers 
## (very highly expressed genes).  A more robust normalisation criterion 
## is to use the 75th percentile, or the median. We use the median, somewhat arbitrarily, 
## beause it gives a nice alignment on the boxplots.
cpms.libsum <- cpm(all.counts.epsilon)    ## Counts per million reads, normalised by library sum
cpms.perc75 <- cpm(all.counts.epsilon, lib.size = stats.per.sample$perc75)    ## Counts per million reads, normalised by 75th percentile
cpms.perc95 <- cpm(all.counts.epsilon, lib.size = stats.per.sample$perc95)    ## Counts per million reads, normalised by 95th percentile
cpms.median <- cpm(all.counts.epsilon, lib.size = stats.per.sample$median)    ## Counts per million reads, normalised by sample-wise median count
#cpms <- cpms.median ## Choose one normalization factor for the CPMs used below
cpms <- cpms.perc75 ## Choose one normalization factor for the CPMs used below
cpms.log10 <- log10(cpms) ## Log-10 transformed CPMs, with the epsilon for 0 counts
cpms.log2 <- log2(cpms) ## Log-10 transformed CPMs, with the epsilon for 0 counts

## Compute Trimmed Means of M Values (TMM): TO BE DONE
stats.per.sample$cpm.mean <- apply(cpms, 2, mean)
stats.per.sample$log2.cpm.mean <- apply(cpms.log2, 2, mean)
stats.per.sample$log10.cpm.mean <- apply(cpms.log10, 2, mean)

################################################################
## Export stats per sample
#
# names(stats.per.sample)
# head(stats.per.sample)
verbose("Exporting stats per sample", 1)
sample.summary.file <- paste(sep="", prefix["general.file"], "_summary_per_sample.tab")
write.table(x = stats.per.sample, row.names = TRUE, col.names=NA, 
            file = sample.summary.file, sep = "\t", quote=FALSE)
verbose(paste(sep="", "\tSummary per sample\t", sample.summary.file), 1)
```

### Sample sizes

```{r library_sizes_barplot, fig.width=6, fig.height=6}
libsize.barplot(stats.per.sample, plot.file=NULL)
```


### Read count distributions

```{r count_boxplots, fig.width=10, fig.height=10}
par(mfrow=c(2,2))
  ## Boxplot of raw counts
  count.boxplot(all.counts, stats.per.sample, xlab="Raw counts", 
                main="Raw counts per sample")

  ## Boxplot of log10-transformed counts
  count.boxplot(all.counts.log10, stats.per.sample, xlab="log10(counts)", 
                main="log10(counts) per sample")

  ## Boxplot of CPMs
  count.boxplot(cpms, stats.per.sample, xlab="CPM", 
                main="CPMs per sample")
  
  ## Boxplot of log10-transformed CPMs
  count.boxplot(cpms.log10, stats.per.sample, xlab="log10(CPM)", 
                main="log10(CPMs) per sample")
par(mfrow=c(1,1))
```


### Count correlations between samples

```{r count_correl_heatmap, fig.width=8, fig.height=8}
count.correl.heatmap(all.counts)
```


## Detection of differentially expressed genes

### Design


```{r Read the design, warning=FALSE}

## Read the design file, which indicates the anlayses to be done.
## Each row specifies one differential expression analysis, which 
## consists in comparing two conditions. 
verbose(paste("Reading design file: ", design.file), 2)
design <- read.delim(design.file, sep="\t", 
                     comment=";", header = T, row.names=NULL)


```

<!-- TO DO: print a table with the design -->


* * * 

## Directories and files

### Input files

| Content   | File  |
|-----------|-------|
| Base directory | [`r dir.base`](`r dir.base`) |
| Raw counts | [`r all.counts.table`](`r all.counts.table`) |
| Gene annotations (GTF file) | [`r gtf.file`](`r gtf.file`) |

### Output files

| Content   | File  |
|-----------|-------|
| Output directory | [`r dir.DEG`](`r dir.DEG`) |
| Gene info table | [`r gene.info.out`](`r gene.info.out`) |
| Sample summary table | [`r sample.summary.file`](`r sample.summary.file`) |

* * *
