import pandas as pd


def merge_count_files(count_files:list, split_suffix:str=""):
    """Read a list of tab-delimited files containing counts per genes
    (column 1 = gene ID, column 2 = read counts) and merge all counts
    in a single data frame (one row per gene, one column per
    sample).

    """

    ## !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ## JVH: THIS SHOULD BE REVISED: it will be more robust to
    ## merge count files with python pandas library.
    ## http://pandas.pydata.org/pandas-docs/stable/merging.html#set-logic-on-the-other-axes

    # Initilizing headers for all_count file
#    table_header = "gene_id"

    # # Condition only true on the first loop
    # gene_ids_ok = True
    # list_line = []

    ## Instantiate an empty data frame to merge the counts for
    ## each sample (one column per sample, one row per gene).
    count_table = pd.DataFrame()

    # Parse a count files of all replicates of all conditions
    for i in range(len(COUNT_FILES)):
        count_file = COUNT_FILES[i]


        ## !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        ## JVH: THIS SHOULD BE REVISED: the headers should simply be the
        ## sample IDs.

        # The sample ID is currently computed from the file name
        # sample_id = count_file.split("/")[-1]         ## Remove path of count table files
        sample_id = os.path.basename(count_file)        ## Take the basename of the count file as sample ID
        sample_id = sample_id.split(split_suffix)[0]    ## Split the suffix if defined
#        table_header += "\t" + sample_id                ## Add the current sample ID to the header line

        if verbosity >= 3:
            print("\t".join(["\tReading counts", str(i), sample_id, count_file]))

        ## Read the count table for the current sample
        sample_counts = pd.read_csv(count_file, sep="\t", names=[sample_id],  index_col=0)

        ## Add a column with current sample to the count table
        count_table = pd.concat([count_table, sample_counts], axis=1)
            
        # count_res = open(count_file)
        # #Check if first loop
        # if gene_ids_ok:
        #     for line in count_res:
        #         # Create gene_ids
        #         gene_counts_ids = line.split("\t")
        #         list_line.append(gene_counts_ids[0] + "\t" + gene_counts_ids[1].strip("\n"))
        #     gene_ids_ok = False

        # #If gene_ids already exist add count column
        # list_file = count_res.readlines()
        # for j in range(len(list_file)):
        #     gene_counts = list_file[j].split("\t")
        #     list_line[j] += "\t" + gene_counts[1].strip("\n")
        # count_res.close()

    # # Write the content of the variable all_counts in a file
    # all_counts = open(output.all_counts_file + "_old.tab", 'w')
    # all_counts.write(table_header + "\n")
    # for elm in list_line:
    #     all_counts.write(elm + "\n")
    # all_counts.close()
    return(count_table)

rule HTseq_allcount_params:
    """Create a tab-delimited file regrouping the counts of reads per gene
    for all the samples, by collecting the sample-specific counts
    generated by htseq-count.

    This rule also creates an R file with the parameters that will be
    used for the detection of differentially expressed genes
    (currently working with rules edgeR and DESeq2).

    The input is a list of count files, such as those produced by
    htseq-count: the first column indicates gene IDs, the second
    column the read counts.

    """

    input:  COUNT_FILES
    output: R_params = PARAMS_R, \
            all_counts_file = ALL_COUNTS
    log: config["dir"]["results"] + "DEG/all_count.log"
    benchmark: config["dir"]["results"] + "DEG/all_count_benchmark.json"
    params: qsub = config["qsub"] + " -q short -e " + config["dir"]["results"] + "DEG/all_count_qsub.err -o " + config["dir"]["results"] + "DEG/all_count_qsub.out", \
            cond1 = config["Diff_Exp"]["cond1"], \
            cond2 = config["Diff_Exp"]["cond2"], \
            dir_results = config["dir"]["results"]

    run:
        verbosity = config["verbosity"]

        if verbosity >= 2:
            print("Generating count table\t" + output.all_counts_file)

    
        # Get name of R_params file without path.
#        R_params_basename = output.R_params.split("/")[-1]
        R_params_basename = os.path.basename(output.R_params)

        # Get common suffix of all the aligned read files from name of
        # R_params.  
        # 
        # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        # NOTE BY JVH (2015-08-14): THIS SHOULD BE
        # REVISED. The script relies on the fact that the suffix of
        # all the count files is the prefix of the parameter file.
        split_suffix = "_" + R_params_basename.replace("_params.R", "")

        # Get extention of count files by splitting the first file of
        # the list. Note that this assumes that all count files have
        # the same extension.
        #
        # complet_path_count = COUNT_FILES[0].rsplit("/", maxsplit=1)
        # #count_ext = complet_path_count[-1].rsplit("_")[-1]
        # count_ext = complet_path_count[-1].rsplit(".")[-1]
        first_file_basename = os.path.basename(COUNT_FILES[0])
        count_ext = os.path.splitext(first_file_basename)[1]

        count_table = merge_count_files(COUNT_FILES, split_suffix=split_suffix)

        ## Export the count table in tab-delimited text file, with a
        ## column header (sample IDs) and row names (gene IDs).
        count_table.to_csv(output.all_counts_file, sep="\t", 
                           header=True, index=True, index_label="gene_id")

        ## For debugging
        if verbosity >= 4:
            print("split_suffix" + "\t" + split_suffix)
            print("count_ext" + "\t" + count_ext)
#            print("table_header" + "\t" + table_header)
            if verbosity >= 10:
                print("count_table\t" + str(count_table.head()))

        if verbosity >= 3:
            print("Exported count table\t" + output.all_counts_file)

        ################################################################
        ## Exporting parameters for differential analysis with R


        ## !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        ## JVH: In this version, the associations between samples and
        ## conditions are indicated in the configuration file. This
        ## can become eavy to manage, and it is redundant since this
        ## information should be present in the sample description
        ## file. I will adapt this

        if verbosity >= 2:
            print("Exporting R parameters\t" + output.R_params)

        # Initializing variables
        counts_f = []
        sample_condition_py = []
        sample_names_py = []
        conditions = []
        n_rep = []
        output_list = []

        # Get parameters
        condition_1 = params.cond1
        condition_2 = params.cond2
        dir_results  = params.dir_results

        if verbosity >= 3:
            print("condition_1" + "\t" + ";".join(condition_1))
            print("condition_2" + "\t" + ";".join(condition_2))
            print("R_params_basename" + "\t" + R_params_basename)

        # Iterate over the analyses. One analysis consists in
        # detecting differentially expressed genes between two
        # conditions. This function exports the parameters for one or
        # several analyses. 
        for i in range(len(condition_1)):
            cond_1 = condition_1[i] # First condition for current analysis
            cond_2 = condition_2[i] # Second condition for current analysis
            if verbosity >= 2:
                print(cond_1 + "\tversus\t" + cond_2)

            output_list.append(dir_results + "DEG/" + cond_1 + "_vs_" + cond_2 + "/" + cond_1 + "_VS_" + cond_2 + "_" + split_suffix + ".tab")            

            # Get the respective lists R_1, R_2 with the sample IDs
            # for the two selected conditions (there should be several
            # samples per condition).
            R_1 = []
            R_2 = []
            if ("Diff_Exp" in config) and (cond_1 in config["Diff_Exp"]) and (cond_2 in config["Diff_Exp"]):
                R_1 = config["Diff_Exp"][cond_1]
                R_2 = config["Diff_Exp"][cond_2]
            else:
                R_1 = list(SAMPLE_IDS[SAMPLE_CONDITIONS == cond_1])
                R_2 = list(SAMPLE_IDS[SAMPLE_CONDITIONS == cond_2])

            if verbosity >= 2:
                print("\t" + cond_1 + "\t" + ";".join(R_1))
                print("\t" + cond_2 + "\t" + ";".join(R_2))
                

            # List path + name of replicats
            files_list = []
            files_list_R1 = []
            files_list_R2 = []
            for i in range(len(R_1)) :
                files_list_R1.append('"' + config["dir"]["results"] + R_1[i]+ "/" + R_1[i] + "_" + split_suffix + "." + count_ext + '"')
                files_list_R2.append('"' + config["dir"]["results"] + R_2[i]+ "/" + R_2[i] + "_" + split_suffix + "." + count_ext + '"')

            files_list = files_list_R1 + files_list_R2
            
            # Join the count files in string
            counts_f.append("c(" + ', \n '.join(files_list) + ")")
            #Get the list of condition 
            sample_condition_temp = ("'" + cond_1 + "',") * len(R_1) + ("'" +cond_2 + "',") * len(R_2)
            #remove the last coma
            sample_condition_py.append("c(" +  sample_condition_temp[:-1] + ")")

            # Get list of replicates
            sample_names_py.append("c('" + "','".join(R_1) + "','" + "','".join(R_2) + "')")

            # List of conditions
            conditions.append("c('" + cond_1 + "','" + cond_2 + "')")

            if len(R_1) >= len(R_2):
                n_rep.append(str(len(R_2)))
            else:
                n_rep.append(str(len(R_1)))
        
        out_R=open(output.R_params, 'w')
        out_R.write("## Root path \n" \
                    + "data.root <-'" +  config["dir"]["results"] + "' \n \n" \
                    + "## Table containing the counts of reads per gene (rows) for each sample (columns)  \n" \
                    + "all.counts.table <- '" + output.all_counts_file + "' \n \n" \
                    + "## Description of the conditions \n" \
                    + "conditions <- c('" + "','".join(config["Diff_Exp"]["conditions"]) + "') \n" \
                    + "n.rep <-c(" + ','.join(n_rep) + ")\n \n" \
                    + "count.files <-c('" + "', \n '".join(COUNT_FILES) + "') \n \n"\
                    + "FDR.threshold <- " + config["edgeR"]["FDR_threshold"] + "\n \n \n"\
                    + "################################################################ \n" \
                    + "## Structure of the comparisons for edgeR \n \n" \
                    + "comparisons <-list(" + ','.join(conditions) + ")\n" \
                    + "comparisons.cond1 <-list('" + "','".join(condition_1) + "') \n" \
                    + "comparsions.cond2 <-list('" + "','".join(condition_2) + "') \n" \
                    + "counts.files.per.comparisons <- list(" + ', \n'.join(counts_f) + ")\n" \
                    + "condition.per.comparisons <-list(" + ', \n '.join(sample_condition_py) + ")\n" \
                    + "names.per.comparisons <-list(" +  ', \n '.join(sample_names_py) + ")\n \n" \
                    + "## List of cvs files that will be created by edgeR \n" \
                    + "output <-c('" + "', \n '".join(output_list) + "') \n \n" \
                    + "#### END OF THE CONFIG FILE \n" \
                    + "################################################################" \
                )     
        out_R.close()
